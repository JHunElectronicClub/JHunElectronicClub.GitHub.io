<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jhunelectronicclub.com</id>
    <title>江汉大学电子爱好者协会</title>
    <updated>2021-09-19T04:28:32.983Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jhunelectronicclub.com"/>
    <link rel="self" href="https://jhunelectronicclub.com/atom.xml"/>
    <subtitle>立德 致用 兼容 创新</subtitle>
    <logo>https://jhunelectronicclub.com/images/avatar.png</logo>
    <icon>https://jhunelectronicclub.com/favicon.ico</icon>
    <rights>All rights reserved 2021, 江汉大学电子爱好者协会</rights>
    <entry>
        <title type="html"><![CDATA[图像插值]]></title>
        <id>https://jhunelectronicclub.com/Image-interpolation/</id>
        <link href="https://jhunelectronicclub.com/Image-interpolation/">
        </link>
        <updated>2021-09-18T15:53:55.000Z</updated>
        <content type="html"><![CDATA[<p># <strong>图像插值</strong></p>
<p>## <strong>1碎碎念</strong></p>
<figure data-type="image" tabindex="1"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/others.jpg" alt="others" loading="lazy"></figure>
<p>语言由于只会C类和python</p>
<p>鉴于python比较普及,这次准备用python讲解, 用的opencv库(sklearn和tensorflow貌似也可以做,不过没必要)</p>
<p>opencv是用C写的,opencv-python库我开着看了看,只能找到定义,没翻出源代码</p>
<p>源文件是c转过来的pyd文件,这东西不好反编译,我放弃了从这方面起手讲</p>
<p>图像处理在matlab上比较好用,毕竟图像都是矩阵,二值图,灰度图二阶,彩图三阶, matlab的矩阵处理能力太强了,由于这个原因, Matplotlib库在图像处理方面也有很多贡献</p>
<figure data-type="image" tabindex="2"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/study.jpg" alt="学个屁" loading="lazy"></figure>
<p><a href="https://sym1018.xyz">快点我,夹带私货</a></p>
<p>## <strong>2原理</strong></p>
<p>插值指的是利用已知数据去预测未知数据，图像插值则是给定一个像素点，根据它周围像素点的信息来对该像素点的值进行预测。当我们调整图片尺寸或者对图片变形的时候常会用到图片插值。比如说我们想把一个4x4的图片，扩展成7x7 就会产生一些新的像素点</p>
<p>如何给这些值赋值， 就是图像插值所要解决的问题</p>
<figure data-type="image" tabindex="3"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/1.png" alt="像素赋值" loading="lazy"></figure>
<p>常见的插值算法可以分为两类：自适应和非自适应。 自适应的方法可以根据插值的内容来改变（尖锐的边缘或者是平滑的纹理），非自适应的方法对所有的像素点都进行同样的处理。 非自适应算法包括：最近邻，双线性，双三次，样条，sinc，lanczos等。 由于其复杂度, 这些插值的时候使用从0 to 256 (or more) 邻近像素。 包含越多的邻近像素，他们越精确，但是花费的时间也越长。这些算法可以用来扭曲和缩放照片。</p>
<p>我们主要介绍最近邻，线性插值，双三次插值三种插值方式，下图是对双三次插值与一些一维和二维插值的比较。 黑色和红色/黄色/绿色/蓝色点分别对应于插值点和相邻样本。 点的高度与其值相对应。</p>
<figure data-type="image" tabindex="4"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/7.png" alt="插值演示" title="插值演示" loading="lazy"></figure>
<p>### <strong>最近邻插值 INTER_NEAREST</strong></p>
<p>最近邻插值法， 找到与之距离最相近的邻居（原来就存在的像素点， 黑点）， 赋值与其相同。</p>
<figure data-type="image" tabindex="5"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/" alt="最近邻插值 INTER_NEAREST" title="最近邻插值 INTER_NEAREST" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/6.png" alt="示例" title="示例" loading="lazy"></figure>
<p><strong><strong>问题 如果距离四个点都相等（中心处）要如何处理？</strong></strong></p>
<p>### <strong>一维线性插值 Inter linear</strong></p>
<p>我们先来看一个简单的一维线形插值的例子。</p>
<p>已知两点（红色） ，在给出一个蓝点的x坐标， 求y。</p>
<p>所以需要根据两个红点确定一条直线，求出直线的表达式， 然后再将x坐标带进去</p>
<figure data-type="image" tabindex="7"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/4.png" alt="公式" title="公式" loading="lazy"></figure>
<p>### <strong>双线性插值 Bilinear interpolation(opencv默认)</strong></p>
<p>在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。见下图：</p>
<figure data-type="image" tabindex="8"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/8.png" alt="双线性插值" title="双线性插值" loading="lazy"></figure>
<p>我们想得到未知函数 f 在点 P = (x, y) 的值，假设我们已知函数 f 在 Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。最常见的情况，f就是一个像素点的像素值。思路是我们可以将求解过程分解为两次插值过程，首先在x轴方向上进行插值，根据点Q11,Q21得到</p>
<figure data-type="image" tabindex="9"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/fr1.png" alt="fr1" title="fr1" loading="lazy"></figure>
<p>根据点Q12,Q22得到</p>
<figure data-type="image" tabindex="10"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/fr2.png" alt="fr2" title="fr2" loading="lazy"></figure>
<p>然后在y轴方向上进行插值， 根据点R1 和R2得到</p>
<figure data-type="image" tabindex="11"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/fp1.png" alt="fp1" title="fp1" loading="lazy"></figure>
<p>整理得</p>
<figure data-type="image" tabindex="12"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/fp2.png" alt="fp2" title="fp2" loading="lazy"></figure>
<p>仍以刚刚的AB图像为例，B中(1,4)点对应A图中(0.43, 1.71)这个点，将该点像素值f(0.43,1.71)写成 f(i+u,j+v)的形式，则 u=0.43,v=0.71, i=0, j=1，该点在A中是虚拟存在的，先找到A中与它临近的四个实际存在的像素点</p>
<pre><code>（0，1） （0，2）
（1，1） （1，2）
</code></pre>
<p>根据上边整理的公式得</p>
<pre><code>f(i+u,j+v) = (1-u)(1-v)f(i,j) + (1-u)vf(i,j+1) + u(1-v)f(i+1,j) + uvf(i+1,j+1)
</code></pre>
<p>由于图像双线性插值只会用相邻的4个点，因此上述公式的分母都是1, 带入相应数值</p>
<pre><code>f(0+0.43, 1+0.71) = 0.57*0.29*f(0,1)+0.57*0.71*f(0, 2)+0.43*0.29*f(1,1)+0.43*0.71*f(1,2)
</code></pre>
<p>### <strong>双三次插值 Bicubic interpolation</strong></p>
<p>假设源图像A大小为m<strong>n，缩放K倍后的目标图像B的大小为M</strong>N，即K=M/m。A的每一个像素点是已知的，B是未知的，我们想要求出目标图像B中每一像素点(X,Y)的值，必须先找出像素(X,Y)在源图像A中对应的像素(x,y)，再根据源图像A距离像素(x,y)最近的16个像素点作为计算目标图像B(X,Y)处像素值的参数，利用BiCubic基函数求出16个像素点的权重，图B像素(x,y)的值就等于16个像素点的加权叠加。</p>
<figure data-type="image" tabindex="13"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/9.png" alt="4x4" title="4x4" loading="lazy"></figure>
<p>根据比例关系x/X=m/M=1/K，我们可以得到B(X,Y)在A上的对应坐标为A(x,y)=A(X**(m/M),Y**(n/N))=A(X/K,Y/K)。如图所示P点就是目标图像B在(X,Y)处对应于源图像A中的位置，P的坐标位置会出现小数部分，所以我们假设 P的坐标为P(x+u,y+v)，其中x,y分别表示整数部分，u,v分别表示小数部分（蓝点到a11方格中红点的距离）。那么我们就可以得到如图所示的最近16个像素的位置，在这里用a(i,j)(i,j=0,1,2,3)来表示，如上图。</p>
<figure data-type="image" tabindex="14"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/10.png" alt="BiCubic基函数" title="BiCubic基函数" loading="lazy"></figure>
<p>我们要做的就是求出BiCubic函数中的参数x,从而获得上面所说的16个像素所对应的权重W(x)。BiCubic基函数是一维的，而像素是二维的，所以我们将像素点的行与列分开计算。BiCubic函数中的参数x表示该像素点到P点的距离，例如a00距离P(x+u,y+v)的距离为(1+u,1+v)，因此a00的横坐标权重i_0=W(1+u)，纵坐标权重j_0=W(1+v)，a00对B(X,Y)的贡献值为：（a00像素值）* <em>i_0</em>* j_0。因此，a0X的横坐标权重分别为W(1+u)，W(u)，W(1-u)，W(2-u)；ay0的纵坐标权重分别为W(1+v)，W(v)，W(1-v)，W(2-v)；B(X,Y)像素值为：</p>
<figure data-type="image" tabindex="15"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/11.png" alt="像素值" title="像素值" loading="lazy"></figure>
<p>其中W(m)表示amn横坐标上的权重，W(n)表示amn纵坐标上的权重。三次曲线插值方法相较于前面的最近邻和线性插值而言计算量较大，但插值后的图像效果最好</p>
<p>## <strong>3应用(opencv-python库)</strong></p>
<p>```python</p>
<p>cv2.resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) → dst</p>
<p>```</p>
<p>其中interpolation的选项包括</p>
<figure data-type="image" tabindex="16"><img src="https://jhunelectronicclub.com/post-images/Image_interpolation/2.png" alt="插值方法" title="插值方法" loading="lazy"></figure>
<p>### <strong>一个简单的示例</strong></p>
<p>```python</p>
<p>import cv2</p>
<p>img = cv2.imread(r&quot;56330889_p0.png&quot;, cv2.IMREAD_UNCHANGED)</p>
<p>print('Original Dimensions : ', img.shape)</p>
<p>scale_percent = 50  # 伸缩百分比</p>
<p>width = int(img.shape[1] * scale_percent / 100)</p>
<p>height = int(img.shape[0] * scale_percent / 100)</p>
<p>dim = (width, height)</p>
<p># resize image</p>
<p>resized = cv2.resize(img, dim, interpolation=cv2.INTER_AREA)</p>
<p>print('Resized Dimensions : ', resized.shape)</p>
<p>cv2.imshow(&quot;Resized image&quot;, resized)</p>
<p>cv2.waitKey(0)</p>
<p>cv2.destroyAllWindows()</p>
<p>```</p>
<p>## <strong>4自己编写函数</strong></p>
<p>```python</p>
<p>#最邻近算法</p>
<p>import cv2</p>
<p>import numpy as np</p>
<p>def nearest_resize(img, src_size):</p>
<p>​    h, w, c = img.shape</p>
<p>​    src = np.zeros((src_size[0], src_size[1], 3), dtype=np.uint8)</p>
<p>​    if h == src_size[0] and w == src_size[1]:</p>
<p>​        return img</p>
<p>​    for i in range(src_size[0]):</p>
<p>​        for j in range(src_size[1]):</p>
<p>​            # round()四舍五入的函数</p>
<p>​            src_x = round(i * (h / src_size[0]))</p>
<p>​            src_y = round(j * (w / src_size[1]))</p>
<p>​            src[i, j] = img[src_x, src_y]</p>
<p>​    return src</p>
<p>img = cv2.imread(&quot;56330889_p0.png&quot;)</p>
<p>cv2.imshow(&quot;img&quot;, img)</p>
<p>src = nearest_resize(img, (100, 100))</p>
<p>cv2.imshow(&quot;resize_img&quot;, src)</p>
<p>cv2.waitKey(0)</p>
<p>cv2.destroyAllWindows()</p>
<p>```</p>
<p>```python</p>
<p>#双线性插值</p>
<p>import numpy as np</p>
<p>import cv2</p>
<p>import math</p>
<p>def bi_linear(src, dst, target_size):</p>
<p>​    pic = cv2.imread(src)       # 读取输入图像</p>
<p>​    th, tw = target_size[0], target_size[1]</p>
<p>​    emptyImage = np.zeros(target_size, np.uint8)</p>
<p>​    for k in range(3):</p>
<p>​        for i in range(th):</p>
<p>​            for j in range(tw):</p>
<p>​                # 首先找到在原图中对应的点的(X, Y)坐标</p>
<p>​                corr_x = (i+0.5)/th*pic.shape[0]-0.5</p>
<p>​                corr_y = (j+0.5)/tw*pic.shape[1]-0.5</p>
<p>​                # if i<em>pic.shape[0]%th==0 and j</em>pic.shape[1]%tw==0:</p>
<p>​                # 对应的点正好是一个像素点，直接拷贝</p>
<p>​                # emptyImage[i, j, k] = pic[int(corr_x), int(corr_y), k]</p>
<p>​                point1 = (math.floor(corr_x), math.floor(corr_y))</p>
<p>​                # 左上角的点</p>
<p>​                point2 = (point1[0], point1[1]+1)</p>
<p>​                point3 = (point1[0]+1, point1[1])</p>
<p>​                point4 = (point1[0]+1, point1[1]+1)</p>
<p>​                fr1 = (point2[1]-corr_y)*pic[point1[0], point1[1], k] + (corr_y-point1[1])*pic[point2[0], point2[1], k]</p>
<p>​                fr2 = (point2[1]-corr_y)*pic[point3[0], point3[1], k] + (corr_y-point1[1])*pic[point4[0], point4[1], k]</p>
<p>​                emptyImage[i, j, k] = (point3[0]-corr_x)*fr1 + (corr_x-point1[0])*fr2</p>
<p>​    cv2.imwrite(dst, emptyImage)</p>
<p>src = &quot;56330889_p0.png&quot;</p>
<p>dst = 'new.png'</p>
<p>target_size = (100, 100, 3)</p>
<p># 变换后的图像大小</p>
<p>bi_linear(src, dst, target_size)</p>
<p>```</p>
<p>```python</p>
<p>#双三次插值</p>
<p>import cv2</p>
<p>import numpy as np</p>
<p>import math</p>
<p>import sys, time</p>
<p>import os</p>
<p># Interpolation kernel   插值内核</p>
<p># 即上图双三次插值的BiCubic函数</p>
<p>def u(s,a):</p>
<p>​    if (abs(s) &gt;=0) &amp; (abs(s) &lt;=1):</p>
<p>​        return (a+2)<em>(abs(s)**3)-(a+3)</em>(abs(s)**2)+1</p>
<p>​    elif (abs(s) &gt; 1) &amp; (abs(s) &lt;= 2):</p>
<p>​        return a*(abs(s)**3)-(5<em>a)</em>(abs(s)**2)+(8*a)<em>abs(s)-4</em>a</p>
<p>​    return 0</p>
<p>#Paddnig</p>
<p>def padding(img,H,W,C):</p>
<p>​    zimg = np.zeros((H+4,W+4,C))</p>
<p>​    zimg[2:H+2,2:W+2,:C] = img</p>
<p>​    #Pad the first/last two col and row</p>
<p>​    zimg[2:H+2,0:2,:C]=img[:,0:1,:C]</p>
<p>​    zimg[H+2:H+4,2:W+2,:]=img[H-1:H,:,:]</p>
<p>​    zimg[2:H+2,W+2:W+4,:]=img[:,W-1:W,:]</p>
<p>​    zimg[0:2,2:W+2,:C]=img[0:1,:,:C]</p>
<p>​    #Pad the missing eight points</p>
<p>​    zimg[0:2,0:2,:C]=img[0,0,:C]</p>
<p>​    zimg[H+2:H+4,0:2,:C]=img[H-1,0,:C]</p>
<p>​    zimg[H+2:H+4,W+2:W+4,:C]=img[H-1,W-1,:C]</p>
<p>​    zimg[0:2,W+2:W+4,:C]=img[0,W-1,:C]</p>
<p>​    return zimg</p>
<p>def get_progressbar_str(progress):</p>
<p>​    END = 170</p>
<p>​    MAX_LEN = 30</p>
<p>​    BAR_LEN = int(MAX_LEN * progress)</p>
<p>​    return ('Progress:[' + '=' * BAR_LEN +</p>
<p>​            ('&gt;' if BAR_LEN &lt; MAX_LEN else '') +</p>
<p>​            ' ' * (MAX_LEN - BAR_LEN) +</p>
<p>​            '] %.1f%%' % (progress * 100.))</p>
<p># Bicubic operation   双三次插值</p>
<p>def bicubic(img, ratio, a):</p>
<p>​    #Get image size</p>
<p>​    H,W,C = img.shape</p>
<p>​    img = padding(img,H,W,C)</p>
<p>​    #Create new image</p>
<p>​    dH = math.floor(H*ratio)</p>
<p>​    dW = math.floor(W*ratio)</p>
<p>​    dst = np.zeros((dH, dW, 3))</p>
<p>​    h = 1/ratio</p>
<p>​</p>
<p>​    print('Start bicubic interpolation')</p>
<p>​    print('It will take a little while...')</p>
<p>​    inc = 0</p>
<p>​    for c in range(C):</p>
<p>​        for j in range(dH):</p>
<p>​            for i in range(dW):</p>
<p>​                x, y = i * h + 2 , j * h + 2</p>
<p>​                x1 = 1 + x - math.floor(x)</p>
<p>​                x2 = x - math.floor(x)</p>
<p>​                x3 = math.floor(x) + 1 - x</p>
<p>​                x4 = math.floor(x) + 2 - x</p>
<p>​                y1 = 1 + y - math.floor(y)</p>
<p>​                y2 = y - math.floor(y)</p>
<p>​                y3 = math.floor(y) + 1 - y</p>
<p>​                y4 = math.floor(y) + 2 - y</p>
<p>​                mat_l = np.matrix([[u(x1,a),u(x2,a),u(x3,a),u(x4,a)]])</p>
<p>​                mat_m = np.matrix([[img[int(y-y1),int(x-x1),c],img[int(y-y2),int(x-x1),c],img[int(y+y3),int(x-x1),c],img[int(y+y4),int(x-x1),c]],</p>
<p>​                                   [img[int(y-y1),int(x-x2),c],img[int(y-y2),int(x-x2),c],img[int(y+y3),int(x-x2),c],img[int(y+y4),int(x-x2),c]],</p>
<p>​                                   [img[int(y-y1),int(x+x3),c],img[int(y-y2),int(x+x3),c],img[int(y+y3),int(x+x3),c],img[int(y+y4),int(x+x3),c]],</p>
<p>​                                   [img[int(y-y1),int(x+x4),c],img[int(y-y2),int(x+x4),c],img[int(y+y3),int(x+x4),c],img[int(y+y4),int(x+x4),c]]])</p>
<p>​                mat_r = np.matrix([[u(y1,a)],[u(y2,a)],[u(y3,a)],[u(y4,a)]])</p>
<p>​                dst[j, i, c] = np.dot(np.dot(mat_l, mat_m),mat_r)</p>
<p>​                # Print progress</p>
<p>​                inc = inc + 1</p>
<p>​                sys.stderr.write('\r\033[K' + get_progressbar_str(inc/(C<em>dH</em>dW)))</p>
<p>​                sys.stderr.flush()</p>
<p>​    sys.stderr.write('\n')</p>
<p>​    sys.stderr.flush()</p>
<p>​    return dst</p>
<p># Scale factor</p>
<p>ratio = 0.5            # 放大缩小系数为0.5</p>
<p># Coefficient</p>
<p>a = -1/2</p>
<p># Read image</p>
<p>img = cv2.imread('56330889_p0.jpg')</p>
<p>dst = bicubic(img, ratio, a)</p>
<p>print('Completed!')</p>
<p>cv2.imwrite( 'new1.png' , dst)</p>
<p>```</p>
<p>## <strong>5参考文献</strong></p>
<p>别怪我没按标准文献列,太懒了</p>
<p><a href="https://docs.opencv.org/master/da/d54/group__imgproc__transform.html">Geometric Image Transformations</a></p>
<p><a href="http://www.1zlab.com/wiki/python-opencv-tutorial/opencv-interpolation-algrithm">图像插值算法</a></p>
<p><a href="https://www.cnblogs.com/laozhanghahaha/p/12580822.html">图像插值算法总结</a></p>
<p><a href="https://www.tutorialkart.com/opencv/python/opencv-python-resize-image/">OpenCV Resize image using cv2.resize()</a></p>
<p><a href="https://blog.csdn.net/weixin_45875199/article/details/107181164">python3实现bicubic(双三次插值)重建四倍放大图像</a></p>
<p><a href="https://blog.csdn.net/pku_Coder/article/details/82690128">双线性插值算法以及python实现</a></p>
<p><a href="https://sym1018.xyz">给我博客加点流量吧,快点我</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[各种语言命名规范]]></title>
        <id>https://jhunelectronicclub.com/Naming_conventions/</id>
        <link href="https://jhunelectronicclub.com/Naming_conventions/">
        </link>
        <updated>2021-09-12T02:50:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言：</h1>
<p>这里想要疏通一下各种语言的命名规范（注意：是写给我自己的啦！也就是规范我的个人习惯！）由于自己在编程的时候，在切换各种编程语言的时候，总是会在命名上面停顿，所以想要在此疏通一下自己的习惯，同时也是将自己的习惯分享出来，如果你看到了这篇文章的话，有相同的习惯的话，也可以回忆下。最后也是确立自己的命名习惯，如果有不好的，那自己以后也会按着这篇文章来命名，这篇文章也是从网上搜集了一些规范。</p>
<h2 id="cc">C/C++</h2>
<h3 id="普通变量">普通变量</h3>
<p>驼峰命名法：&lt;第一个单词首字母小写，其他单词首字母大写&gt;–printEmployeePaychecks<br>
下划线命名法：&lt;多个单词使用下划线分隔&gt;–print_employee_paychecks<br>
帕斯卡命名法：&lt;每个独立单词的首字母都大写&gt;–PrintEmployeePaychecks</p>
<h3 id="指针变量">指针变量</h3>
<p>采用&quot;ptr_&quot;+的形式来为指针变量命名<br>
如：ptr_start; ptr_end</p>
<h3 id="常量">常量</h3>
<p>每个字母都采用大写形式，中间用“_”分隔开<br>
如：CAR_STATUS_1;CAR_STATUS_2</p>
<h3 id="函数名">函数名</h3>
<p>命名与普通变量命名相同<br>
PrintEmployeePaychecks()<br>
print_employee_paychecks()<br>
PrintEmployeePaychecks()</p>
<h3 id="结构体定义">结构体定义</h3>
<pre><code>typedef struct STUDENT
{
    ... ...
}student;
</code></pre>
<h3 id="文件名称">文件名称</h3>
<p>使用&quot;file_&quot;+大体描述的形式<br>
file_nameOfStudent;file_NumberOfStudent</p>
<h2 id="java">JAVA</h2>
<p>java的命名规则</p>
<h3 id="普通变量-2">普通变量</h3>
<p>驼峰命名法：&lt;第一个单词首字母小写，其他单词首字母大写&gt;–printEmployeePaychecks<br>
下划线命名法：&lt;多个单词使用下划线分隔&gt;–print_employee_paychecks<br>
帕斯卡命名法：&lt;每个独立单词的首字母都大写&gt;–PrintEmployeePaychecks</p>
<h3 id="常量-2">常量</h3>
<p>每个字母都采用大写形式，中间用“_”分隔开<br>
如：CAR_STATUS_1;CAR_STATUS_2<br>
方法名<br>
&lt;驼峰命名法&gt;–printEmployeePaychecks()</p>
<h3 id="类名">类名</h3>
<p>帕斯卡命名法：&lt;每个独立单词的首字母都大写&gt;–PrintEmployeePaychecks</p>
<h3 id="包名">包名</h3>
<p>这里我一般使用中文命名，如：算法分析<br>
建议使用驼峰命名法来命名，如：algorithmAnalysis</p>
<h3 id="项目名">项目名</h3>
<p>我一般是使用“java”+的形式，如：java排序集合<br>
接口名与抽象类名称，与类名一样<br>
异常类名称，使用帕斯卡命名法+Exception,如：SexMissMatchException</p>
<h2 id="python">python</h2>
<h3 id="模块名">模块名：</h3>
<p>尽量短小，并且全部使用小写字母，可以使用下划线分隔多个字母。例如：game_main;game_register</p>
<h3 id="包名-2">包名：</h3>
<p>尽量短小，并且全部使用小写字母，不推荐使用下划线。例如：com.lvzeqi、com.lv</p>
<h3 id="类名-2">类名：</h3>
<p>采用单词首字母大写形式（帕斯卡命名法）BorrrowBook</p>
<h3 id="模块内部类">模块内部类：</h3>
<p>采用下划线“_”+帕斯卡命名法。如：在BorrowBook内部有一个内部类，则使用 _BorrowBook<br>
函数、类的属性和方法的命名规则同模块类似，也是全部使用小写字母，多个字母使用下划线分隔</p>
<h3 id="常量-3">常量：</h3>
<p>命名时全部使用大写字母，可以使用下划线分隔<br>
使用单下划线开头的模块变量或者函数是受保护的，在使用from xxx import*语句从模块中导入时这些变量或者函数不能被导入<br>
使用双下划线“__”开头的实例变量或方法是类私有的</p>
<p>原文链接：https://blog.csdn.net/LCX13141314/article/details/86773700</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[markdown教程]]></title>
        <id>https://jhunelectronicclub.com/markdown_study/</id>
        <link href="https://jhunelectronicclub.com/markdown_study/">
        </link>
        <updated>2021-09-12T02:33:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="导语">导语:</h4>
<blockquote>
<p><a href="http://zh.wikipedia.org/wiki/Markdown">Markdown</a>是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。本文转自<a href="https://sspai.com/post/25137">认识与入门 Markdown</a></p>
</blockquote>
<h2 id="认识markdown">认识Markdown</h2>
<p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如<a href="http://jianshu.io">简书</a>）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="http://getcloudapp.com">CloudApp</a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持使用 Mou 这类 Markdown 工具进行编辑并直接上传。</p>
<h3 id="markdown官方文档">Markdown官方文档</h3>
<blockquote>
<p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式，阐述这些语法在实际使用中的用法。</p>
</blockquote>
<ul>
<li><a href="https://daringfireball.net/projects/markdown/syntax"><em>创始人John Gruber的Markdown语法说明</em></a></li>
<li><a href="http://wowubuntu.com/markdown/#list"><em>Markdown中文版语法说明</em></a></li>
</ul>
<h3 id="使用markdown的优点">使用Markdown的优点</h3>
<ul>
<li>专注你的文字内容而不是排版样式</li>
<li>轻松的导出HTML、PDF和本身的.md文件</li>
<li>纯文本内容，兼容所有的文本编辑器和文字处理软件</li>
<li>可读、直观。适合所有人的写作语言</li>
</ul>
<h3 id="我该用什么工具">我该用什么工具</h3>
<h4 id="mac平台">Mac平台</h4>
<ul>
<li>在Mac OS X上，我强烈建议你用<a href="mouapp.com">Mou</a>这款免费且十分好用的Markdown编辑器，它支持实时预览，即左边是你编辑的Markdown语言，右边会实时的生成预览效果。其次还有很多同类选择。如果你是个编辑作者，我强烈建议你购买 <a href="www.ulyssesapp.com">Ulysses Ⅲ</a>，这款应用入围了苹果去年 Mac App Store 的 The Best of 2013，相比 Mou 它支持更多的写作格式、多文档的支持。Mou、iA Writer 这些应用都是基于单文档的管理方式，而 Ulysses Ⅲ 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间还可以进行 Combine 处理。</li>
</ul>
<h4 id="windows-ios-web平台">Windows、ios、Web平台</h4>
<ul>
<li>笔者并未使用过Windows下的Markdown工具，但经朋友介绍，有两款还算不错，一款叫<a href="http://www.markdownpad.com">MarkdownPad</a>,另一款叫<a href="http://code52.org/DownmarkerWPF">MarkPad</a>。</li>
<li>iOS 端已有相当多的 app 支持 Markdown 语法编辑，例如 Drafts、Day One、iA Writer 等。</li>
<li>Web 端上，我强烈推荐 <a href="http://jianshu.io">简书</a> 这款产品，上面有无数热爱文字的人在不停的创造、分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，它同样支持左右两栏的实时预览，字体优雅、简洁。</li>
<li>同样是 Web 端，<a href="https://draftin.com">Draftin</a> 这款在线 MD 编辑器也近乎完美。</li>
</ul>
<h2 id="markdown语法的简要规则">Markdown语法的简要规则</h2>
<h3 id="标题">标题</h3>
<p>标题是每篇文章都需要也是最常见的格式，在Markdown中，如果一段文字被定义为标题，只要在这段文字前加#号即可。</p>
<p><code># 一级标题</code></p>
<h1 id="一级标题">一级标题</h1>
<p><code>## 二级标题</code></p>
<h2 id="二级标题">二级标题</h2>
<p><code>### 三级标题</code></p>
<h3 id="三级标题">三级标题</h3>
<p>依次类推，总共六级标题，建议在#号后加一个空格，这是最标准的<code>Markdown</code>语法。</p>
<p>###列表<br>
熟悉HTML的同学肯定知道有序列表和无序列表的区别，在Markdown下，列表的显示只需要在文字前加上<code>-</code> 或 <code>*</code> 即可变为无序列表，有序列表则直接在文字前加 <code>1. 2. 3.</code> 注意：符号要和文字之间加上一个空格。</p>
<h4 id="无序列表">无序列表</h4>
<p><code>* 苹果</code></p>
<p><code>* 香蕉</code></p>
<p><code>* 梨</code></p>
<ul>
<li>苹果</li>
<li>香蕉</li>
<li>梨</li>
</ul>
<h4 id="有序列表">有序列表</h4>
<p><code>1. 早饭要吃好</code></p>
<p><code>2. 中饭要吃饱</code></p>
<p><code>3. 晚饭要吃少</code></p>
<ol>
<li>早饭要吃好</li>
<li>中饭要吃饱</li>
<li>晚饭要吃少</li>
</ol>
<h3 id="引用">引用</h3>
<p>如果你需要引用一小段别处的句子，就要用到引用。 只需要在文本前加入 <code>&gt;</code> 这种尖括号(大于号)即可。 要注意符号和文本间的空格。</p>
<p><code>&gt; 床前明月光，疑似地上霜 - 李白</code></p>
<blockquote>
<p>床前明月光，疑似地上霜 - 李白</p>
</blockquote>
<h3 id="图片和链接">图片和链接</h3>
<p>插入链接和插入图片的语法很像，区别在于一个 <code>!</code> 号</p>
<h4 id="插入链接">插入链接</h4>
<p><code>[百度](http://baidu.com)</code></p>
<p><a href="http://baidu.com">百度</a></p>
<h4 id="插入图片">插入图片</h4>
<p><code>![百度LOGO](https://www.baidu.com/img/bd_logo1.png)</code></p>
<figure data-type="image" tabindex="1"><img src="https://www.baidu.com/img/bd_logo1.png" alt="百度LOGO" loading="lazy"></figure>
<h3 id="粗体和斜体">粗体和斜体</h3>
<p>Markdown的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。</p>
<p><code>**这里是粗体**</code><br>
<strong>这里是粗体</strong></p>
<p><code>*这里是斜体*</code><br>
<em>这里是斜体</em></p>
<h3 id="表格">表格</h3>
<p>表格是稍微有些复杂，语法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:center">年龄</th>
<th style="text-align:right">性别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">李雷</td>
<td style="text-align:center">13</td>
<td style="text-align:right">男</td>
</tr>
<tr>
<td style="text-align:left">韩梅梅</td>
<td style="text-align:center">12</td>
<td style="text-align:right">女</td>
</tr>
</tbody>
</table>
<p><code>:---</code>  代表左对齐<br>
<code>:---:</code> 代表居中对齐<br>
<code>---:</code>  代表右对齐</p>
<h3 id="代码框">代码框</h3>
<p>如果你是个程序猿，需要在文章里优雅的引用代码框，在Markdown下实现也非常简单，语法如下：</p>
<h4 id="单行用">单行用``</h4>
<p>` int i = 1; `</p>
<p><code>int i = 1;</code></p>
<h4 id="多行用三个">多行用三个`</h4>
<p>```</p>
<p>int i = 1;</p>
<p>int j = 2;</p>
<p>int k = i + j;</p>
<p>```</p>
<h3 id="转义">转义</h3>
<p>在需要转义的字符前加上 \ 即可</p>
<p>`int i = 1;`</p>
<p><code>int i = 1;</code></p>
<p>转义后：</p>
<p>\`int i = 1;\`</p>
<p>`int i = 1;`</p>
<h3 id="删除线">删除线</h3>
<p>用两个 <code>~</code> 符号包含一段文本就是删除线的语法</p>
<p><code>~~该语句作废~~</code></p>
<p><s>该语句作废</s></p>
<h3 id="分割线">分割线</h3>
<p>分割线的语法用来另起一行，连续输入三个星号 <code>***</code> 即可。</p>
<p><code>***</code></p>
<hr>
<h3 id="小结">小结</h3>
<p>到这里，用Markdown来进行日常的使用应该没有什么大的问题了，再多加练习，配合好用的工具，写起东西来肯定会行云流水。</p>
<p>文章来自<br>
<a href="https://blog.csdn.net/damon_yan/article/details/73263261">Markdown--从入门到精通(md源文件)</a></p>
<h3 id="相关文章推荐">相关文章推荐</h3>
<ul>
<li><a href="http://apple4us.com/2012/02/why-writers-should-use-markdown/">为什么作家应该用Markdown保存自己的文稿</a></li>
<li><a href="https://news.cnblogs.com/n/139649/">为什么我们要学习 Markdown 的三个理由</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git的使用]]></title>
        <id>https://jhunelectronicclub.com/git_use/</id>
        <link href="https://jhunelectronicclub.com/git_use/">
        </link>
        <updated>2021-09-12T01:16:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>既然看到了不如就好好学学吧</strong></p>
<p>本教程意向为新生介绍并熟悉git的基本操作<br>
为后续代码编写与协作打下基础</p>
<p>转自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">git教程</a><br>
详情请配合上述教程使用</p>
<h2 id="简介">简介</h2>
<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>
那什么是版本控制系统<br>
它可以自动记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以</p>
<h2 id="安装">安装</h2>
<h3 id="在linux上安装git">在Linux上安装Git</h3>
<p>首先，你可以试着输入git，看看系统有没有安装Git：<br>
<code>$ git</code><br>
The program 'git' is currently not installed. You can install it by typing:<br>
sudo apt-get install git<br>
像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。<br>
如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。<br>
如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<h3 id="在mac-os-x上安装git">在Mac OS X上安装Git</h3>
<p>如果你正在使用Mac做开发，有两种安装Git的方法。<br>
一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。<br>
第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<h3 id="在windows上安装git">在Windows上安装Git</h3>
<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。<br>
安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<p>$ git config --global user.name &quot;Your Name&quot;<br>
$ git config --global user.email &quot;email@example.com&quot;<br>
因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库">创建版本库</h2>
<p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>
所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre>
<p><code>pwd</code>用于显示当前目录<br>
<strong>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong><br>
第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h2 id="把文件添加到版本库">把文件添加到版本库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>
不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。<br>
因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。<br>
使用Windows的童鞋要特别注意：<br>
千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！<br>
言归正传，现在我们编写一个readme.txt文件，内容如下：</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。<br>
和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。<br>
第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：<br>
<code>$ git add readme.txt</code><br>
执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。<br>
第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre>
<p>简单解释一下<code>git commit</code>命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>
嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。<br>
<code>git commit</code>命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。<br>
为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre>
<h2 id="文件的增删改减">文件的增删改减</h2>
<h3 id="版本回退">版本回退</h3>
<p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<pre><code>$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：</p>
<pre><code>$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>
<p>需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线<br>
好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？<br>
首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD<sup>，上上一个版本就是HEAD</sup><sup>，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100。<br>
现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
</code></pre>
<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software.
</code></pre>
<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p>
<pre><code>$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<p>┌────┐<br>
│HEAD│<br>
└────┘<br>
│<br>
└──&gt; ○ append GPL<br>
│<br>
○ add distributed<br>
│<br>
○ wrote a readme file<br>
改为指向add distributed：</p>
<p>┌────┐<br>
│HEAD│<br>
└────┘<br>
│<br>
│    ○ append GPL<br>
│    │<br>
└──&gt; ○ add distributed<br>
│<br>
○ wrote a readme file<br>
然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<pre><code>$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
</code></pre>
<p>终于舒了口气，从输出可知，<code>append GPL</code>的<code>commit id</code>是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>
<h3 id="工作区与暂存区">工作区与暂存区</h3>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>
先来看名词解释。<br>
工作区（Working Directory）<br>
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：<br>
版本库（Repository）<br>
工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<figure data-type="image" tabindex="1"><img src="https://jhunelectronicclub.com/post-images/1631412965349.jfif" alt="git-repo" loading="lazy"></figure>
<p>分支和HEAD的概念我们以后再讲。<br>
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：<br>
第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；<br>
第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>
因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。<br>
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<br>
俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。<br>
先用<code>git status</code>查看一下状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	LICENSE

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   LICENSE
	modified:   readme.txt
</code></pre>
<p>现在，暂存区的状态就变成这样了：<br>
<img src="https://jhunelectronicclub.com/post-images/1631413103117.jfif" alt="" loading="lazy"><br>
所以，<code>1</code>git add<code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行</code>git commit`就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>现在版本库变成了这样，暂存区就没有任何内容了：<br>
<img src="https://jhunelectronicclub.com/post-images/1631413153703.jfif" alt="" loading="lazy"></p>
<h3 id="管理修改">管理修改</h3>
<p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。<br>
你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。<br>
为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对<code>readme.txt</code>做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>
<p>然后，再修改<code>readme.txt</code>：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre>
<p>提交后，再看看状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>咦，怎么第二次的修改没有被提交？<br>
别激动，我们回顾一下操作过程：<br>
第一次修改 -&gt;<code>git add</code> -&gt; 第二次修改 -&gt;<code>git commit</code><br>
你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。<br>
提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<p>可见，第二次修改确实没有被提交。<br>
那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：<br>
第一次修改 -&gt; <code>git add</code>-&gt; 第二次修改 -&gt;<code>git add</code> -&gt; <code>git commit</code><br>
好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="撤销修改">撤销修改</h3>
<p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的--很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。<br>
现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

$ git add readme.txt
</code></pre>
<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   readme.txt
    ```
Git同样告诉我们，用命令`git reset HEAD &lt;file&gt;`可以把暂存区的修改撤销掉（unstage），重新放回工作区：
</code></pre>
<p>$ git reset HEAD readme.txt<br>
Unstaged changes after reset:<br>
M	readme.txt</p>
<pre><code>`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。
再用`git status`查看一下，现在暂存区是干净的，工作区有修改：
</code></pre>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use &quot;git add <file>...&quot; to update what will be committed)<br>
(use &quot;git checkout -- <file>...&quot; to discard changes in working directory)</p>
<pre><code>modified:   readme.txt
</code></pre>
<pre><code>还记得如何丢弃工作区的修改吗？
</code></pre>
<p>$ git checkout -- readme.txt<br>
$ git status<br>
On branch master<br>
nothing to commit, working tree clean<br>
整个世界终于清静了！</p>
<pre><code>

###删除文件
在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件`test.txt`到Git并且提交：
</code></pre>
<p>$ git add test.txt</p>
<p>$ git commit -m &quot;add test.txt&quot;<br>
[master b84166e] add test.txt<br>
1 file changed, 1 insertion(+)<br>
create mode 100644 test.txt</p>
<pre><code>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了：
</code></pre>
<p>$ rm test.txt</p>
<pre><code>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了：
</code></pre>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use &quot;git add/rm <file>...&quot; to update what will be committed)<br>
(use &quot;git checkout -- <file>...&quot; to discard changes in working directory)</p>
<pre><code>deleted:    test.txt
</code></pre>
<p>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</p>
<pre><code>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：
</code></pre>
<p>$ git rm test.txt<br>
rm 'test.txt'</p>
<p>$ git commit -m &quot;remove test.txt&quot;<br>
[master d46f35e] remove test.txt<br>
1 file changed, 1 deletion(-)<br>
delete mode 100644 test.txt</p>
<pre><code>现在，文件就从版本库中被删除了。

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：
</code></pre>
<p>$ git checkout -- test.txt</p>
<pre><code>`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！


## 远程仓库
具体请参考
[远程仓库](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)


## 分支管理与多人协作
具体请参考
[分支管理](https://www.liaoxuefeng.com/wiki/896043488029600/896954848507552)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于本站]]></title>
        <id>https://jhunelectronicclub.com/about/</id>
        <link href="https://jhunelectronicclub.com/about/">
        </link>
        <updated>2021-09-11T09:41:36.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到江汉大学电子爱好者协会，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>这里是江汉大学电子爱好者协会的blog<br>
期待您加入电协</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>暂且是由sym1018在维护本blog</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>ACGNM样样精通</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>email:<br>
symzjs@outlook.com<br>
telegram:<br>
@sym1018</p>
]]></content>
    </entry>
</feed>