<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>git的使用 | 江汉大学电子爱好者协会</title>
<link rel="shortcut icon" href="https://jhunelectronicclub.com/favicon.ico?v=1631980677476">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://jhunelectronicclub.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="git的使用 | 江汉大学电子爱好者协会 - Atom Feed" href="https://jhunelectronicclub.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="既然看到了不如就好好学学吧
本教程意向为新生介绍并熟悉git的基本操作
为后续代码编写与协作打下基础
转自git教程
详情请配合上述教程使用
简介
Git是目前世界上最先进的分布式版本控制系统（没有之一）。
那什么是版本控制系统
它可以自动..." />
    <meta name="keywords" content="study,git,new" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jhunelectronicclub.com">
  <img class="avatar" src="https://jhunelectronicclub.com/images/avatar.png?v=1631980677476" alt="">
  </a>
  <h1 class="site-title">
    江汉大学电子爱好者协会
  </h1>
  <p class="site-description">
    立德 致用 兼容 创新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/about" class="menu">
          about
        </a>
      
    
      
        <a href="/study" class="menu">
          study
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/JHunElectronicClub" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              git的使用
            </h2>
            <div class="post-info">
              <span>
                2021-09-12
              </span>
              <span>
                26 min read
              </span>
              
                <a href="https://jhunelectronicclub.com/study/" class="post-tag">
                  # study
                </a>
              
                <a href="https://jhunelectronicclub.com/git/" class="post-tag">
                  # git
                </a>
              
                <a href="https://jhunelectronicclub.com/new/" class="post-tag">
                  # new
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p><strong>既然看到了不如就好好学学吧</strong></p>
<p>本教程意向为新生介绍并熟悉git的基本操作<br>
为后续代码编写与协作打下基础</p>
<p>转自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">git教程</a><br>
详情请配合上述教程使用</p>
<h2 id="简介">简介</h2>
<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。<br>
那什么是版本控制系统<br>
它可以自动记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以</p>
<h2 id="安装">安装</h2>
<h3 id="在linux上安装git">在Linux上安装Git</h3>
<p>首先，你可以试着输入git，看看系统有没有安装Git：<br>
<code>$ git</code><br>
The program 'git' is currently not installed. You can install it by typing:<br>
sudo apt-get install git<br>
像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。<br>
如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。<br>
如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。</p>
<h3 id="在mac-os-x上安装git">在Mac OS X上安装Git</h3>
<p>如果你正在使用Mac做开发，有两种安装Git的方法。<br>
一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。<br>
第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<h3 id="在windows上安装git">在Windows上安装Git</h3>
<p>在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。<br>
安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<p>$ git config --global user.name &quot;Your Name&quot;<br>
$ git config --global user.email &quot;email@example.com&quot;<br>
因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库">创建版本库</h2>
<p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。<br>
所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre>
<p><code>pwd</code>用于显示当前目录<br>
<strong>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong><br>
第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。<br>
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h2 id="把文件添加到版本库">把文件添加到版本库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。<br>
不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。<br>
因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。<br>
使用Windows的童鞋要特别注意：<br>
千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！<br>
言归正传，现在我们编写一个readme.txt文件，内容如下：</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。<br>
和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。<br>
第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：<br>
<code>$ git add readme.txt</code><br>
执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。<br>
第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre>
<p>简单解释一下<code>git commit</code>命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>
嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。<br>
<code>git commit</code>命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。<br>
为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<pre><code>$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m &quot;add 3 files.&quot;
</code></pre>
<h2 id="文件的增删改减">文件的增删改减</h2>
<h3 id="版本回退">版本回退</h3>
<p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>然后尝试提交：</p>
<pre><code>$ git add readme.txt
$ git commit -m &quot;append GPL&quot;
[master 1094adb] append GPL
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<pre><code>Git is a version control system.
Git is free software.
</code></pre>
<p>版本2：add distributed</p>
<pre><code>Git is a distributed version control system.
Git is free software.
</code></pre>
<p>版本3：append GPL</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<pre><code>$ git log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:06:15 2018 +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：</p>
<pre><code>$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
</code></pre>
<p>需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线<br>
好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？<br>
首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD<sup>，上上一个版本就是HEAD</sup><sup>，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100。<br>
现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<pre><code>$ git reset --hard HEAD^
HEAD is now at e475afc add distributed
</code></pre>
<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software.
</code></pre>
<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p>
<pre><code>$ git log
commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 21:03:36 2018 +0800

    add distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
Date:   Fri May 18 20:59:18 2018 +0800

    wrote a readme file
</code></pre>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<pre><code>$ git reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<p>┌────┐<br>
│HEAD│<br>
└────┘<br>
│<br>
└──&gt; ○ append GPL<br>
│<br>
○ add distributed<br>
│<br>
○ wrote a readme file<br>
改为指向add distributed：</p>
<p>┌────┐<br>
│HEAD│<br>
└────┘<br>
│<br>
│    ○ append GPL<br>
│    │<br>
└──&gt; ○ add distributed<br>
│<br>
○ wrote a readme file<br>
然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<pre><code>$ git reflog
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file
</code></pre>
<p>终于舒了口气，从输出可知，<code>append GPL</code>的<code>commit id</code>是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>
<h3 id="工作区与暂存区">工作区与暂存区</h3>
<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>
先来看名词解释。<br>
工作区（Working Directory）<br>
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：<br>
版本库（Repository）<br>
工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p>
<figure data-type="image" tabindex="1"><img src="https://jhunelectronicclub.com/post-images/1631412965349.jfif" alt="git-repo" loading="lazy"></figure>
<p>分支和HEAD的概念我们以后再讲。<br>
前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：<br>
第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；<br>
第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>
因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。<br>
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。<br>
俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre>
<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。<br>
先用<code>git status</code>查看一下状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)

	LICENSE

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	new file:   LICENSE
	modified:   readme.txt
</code></pre>
<p>现在，暂存区的状态就变成这样了：<br>
<img src="https://jhunelectronicclub.com/post-images/1631413103117.jfif" alt="" loading="lazy"><br>
所以，<code>1</code>git add<code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行</code>git commit`就可以一次性把暂存区的所有修改提交到分支。</p>
<pre><code>$ git commit -m &quot;understand how stage works&quot;
[master e43a48b] understand how stage works
 2 files changed, 2 insertions(+)
 create mode 100644 LICENSE
</code></pre>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<pre><code>$ git status
On branch master
nothing to commit, working tree clean
</code></pre>
<p>现在版本库变成了这样，暂存区就没有任何内容了：<br>
<img src="https://jhunelectronicclub.com/post-images/1631413153703.jfif" alt="" loading="lazy"></p>
<h3 id="管理修改">管理修改</h3>
<p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。<br>
你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。<br>
为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对<code>readme.txt</code>做一个修改，比如加一行内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre>
<p>然后，添加：</p>
<pre><code>$ git add readme.txt
$ git status
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
#       modified:   readme.txt
#
</code></pre>
<p>然后，再修改<code>readme.txt</code>：</p>
<pre><code>$ cat readme.txt 
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>提交：</p>
<pre><code>$ git commit -m &quot;git tracks changes&quot;
[master 519219b] git tracks changes
 1 file changed, 1 insertion(+)
</code></pre>
<p>提交后，再看看状态：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>咦，怎么第二次的修改没有被提交？<br>
别激动，我们回顾一下操作过程：<br>
第一次修改 -&gt;<code>git add</code> -&gt; 第二次修改 -&gt;<code>git commit</code><br>
你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。<br>
提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<pre><code>$ git diff HEAD -- readme.txt 
diff --git a/readme.txt b/readme.txt
index 76d770f..a9c5755 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is free software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre>
<p>可见，第二次修改确实没有被提交。<br>
那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：<br>
第一次修改 -&gt; <code>git add</code>-&gt; 第二次修改 -&gt;<code>git add</code> -&gt; <code>git commit</code><br>
好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="撤销修改">撤销修改</h3>
<p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<pre><code>$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

	modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<pre><code>$ git checkout -- readme.txt
</code></pre>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre>
<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的--很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。<br>
现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

$ git add readme.txt
</code></pre>
<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<pre><code>$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

	modified:   readme.txt
    ```
Git同样告诉我们，用命令`git reset HEAD &lt;file&gt;`可以把暂存区的修改撤销掉（unstage），重新放回工作区：
</code></pre>
<p>$ git reset HEAD readme.txt<br>
Unstaged changes after reset:<br>
M	readme.txt</p>
<pre><code>`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。
再用`git status`查看一下，现在暂存区是干净的，工作区有修改：
</code></pre>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use &quot;git add <file>...&quot; to update what will be committed)<br>
(use &quot;git checkout -- <file>...&quot; to discard changes in working directory)</p>
<pre><code>modified:   readme.txt
</code></pre>
<pre><code>还记得如何丢弃工作区的修改吗？
</code></pre>
<p>$ git checkout -- readme.txt<br>
$ git status<br>
On branch master<br>
nothing to commit, working tree clean<br>
整个世界终于清静了！</p>
<pre><code>

###删除文件
在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件`test.txt`到Git并且提交：
</code></pre>
<p>$ git add test.txt</p>
<p>$ git commit -m &quot;add test.txt&quot;<br>
[master b84166e] add test.txt<br>
1 file changed, 1 insertion(+)<br>
create mode 100644 test.txt</p>
<pre><code>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了：
</code></pre>
<p>$ rm test.txt</p>
<pre><code>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了：
</code></pre>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use &quot;git add/rm <file>...&quot; to update what will be committed)<br>
(use &quot;git checkout -- <file>...&quot; to discard changes in working directory)</p>
<pre><code>deleted:    test.txt
</code></pre>
<p>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</p>
<pre><code>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：
</code></pre>
<p>$ git rm test.txt<br>
rm 'test.txt'</p>
<p>$ git commit -m &quot;remove test.txt&quot;<br>
[master d46f35e] remove test.txt<br>
1 file changed, 1 deletion(-)<br>
delete mode 100644 test.txt</p>
<pre><code>现在，文件就从版本库中被删除了。

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：
</code></pre>
<p>$ git checkout -- test.txt</p>
<pre><code>`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！


## 远程仓库
具体请参考
[远程仓库](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)


## 分支管理与多人协作
具体请参考
[分支管理](https://www.liaoxuefeng.com/wiki/896043488029600/896954848507552)</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a>
<ul>
<li><a href="#%E5%9C%A8linux%E4%B8%8A%E5%AE%89%E8%A3%85git">在Linux上安装Git</a></li>
<li><a href="#%E5%9C%A8mac-os-x%E4%B8%8A%E5%AE%89%E8%A3%85git">在Mac OS X上安装Git</a></li>
<li><a href="#%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%85git">在Windows上安装Git</a></li>
</ul>
</li>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93">创建版本库</a></li>
<li><a href="#%E6%8A%8A%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93">把文件添加到版本库</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E5%87%8F">文件的增删改减</a>
<ul>
<li><a href="#%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80">版本回退</a></li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA">工作区与暂存区</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E4%BF%AE%E6%94%B9">管理修改</a></li>
<li><a href="#%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9">撤销修改</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://jhunelectronicclub.com/about/">
              <h3 class="post-title">
                关于本站
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://jhunelectronicclub.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
